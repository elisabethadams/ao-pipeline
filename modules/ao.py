## ao.py: package to aid AO image reduction for ARIES images of KOIs
#
#  Created 2011-04-19 by E. Adams

## Modules required by this package
import string
from pyraf import iraf
import pyfits
import os

import grabBag as gb


################# UPDATE YOUR MAIN PATH HERE ###############
#### Main folder that houses this project
#mainDir="/data/dupree7/eadams/"
#mainDir="/Remote/From_DUPREE7/"
#mainDir="/Users/era/Research/Projects/Kepler/AO/"
mainDir="/Users/era/Research/From_Ginshiro/AO/"

#### Information from other sources (e.g. 2MASS) lives here
infoDir=mainDir+"info/"

#### All processing scripts (e.g. this pipeline) live here or in subfolders
# Note that the ao-pipeline-dir/ is also a github repository:
#          https://github.com/elisabethadams/ao-pipeline.git
# You'll need to have the data locally so it will run, though
scriptDir = mainDir+"ao-pipeline/"
pipelineReductionDir = scriptDir+"pipeline-reduction/"
pipelineAnalysisDir = scriptDir+"pipeline-analysis/"

#### Raw and reduced data (.fits files) live here
dataDir=mainDir+"data/"

#### Results for each object live here
mainObjectsDir = mainDir+"objects/"
objectsDir = mainObjectsDir + "ARIES/"
objectsDirPHARO = mainObjectsDir + "PHARO/"

#### Plots generated by scripts live here
plotDir=mainDir+"plots/"

#### Tables generated by scripts live here
tableDir=mainDir+"tables/"

#### Batch uploads to the KFOP are generated into this folder
batchDir=mainDir+"batches/"

################# OTHER SETTINGS ###############

### Filters used
filterNames = ["J", "Ks"]
## Misc
cr=['\n']

################# DIRECTORY STRUCTURE FOR PROJECT ###############

## File names.
def koiDir(koi,instr="ARIES"):
	if instr == "PHARO":
		return objectsDirPHARO+koi+"/"
	else:
		return objectsDir+koi+"/"
def koiFilterDir(koi,filt,instr="ARIES"):
	if instr == "PHARO":
		return koiDir(koi,instr)+filt[0]+"/"
	else:
		return koiDir(koi)+filt[0]+"/"
def finalKOIimageFile(koi,filt,instr="ARIES"):
	if instr == "PHARO":
		### We might have a different format. Though it's easier really to just rename the files we get...
		return koi+"_"+filt+".fits"
	else:
		return koi+"_"+filt+".fits"

def finalKOIcooFile(koi,filt):
	return finalKOIimageFile(koi,filt)+".coo"
def settingsFile(koi):
	return koiDir(koi) + "settings_"+koi+".tsv"
def starsFile(koi):
	return koiDir(koi) + "stars_"+koi+".tsv"
def finderPlotName(koi,filt,ext="png"):
	return plotDir+"finders/finder_"+koi+"_"+filt+"."+ext	
## The Shiftlist contains the names of the files used to construct the final image plus the x/y pixel shifts
def shiftListFile(koi,filt):
	return "Shiftlist_"+koi+"_"+filt+".txt"


################# AO PROJECT FUNCTIONS ###############

## Get all KOI that have been reduced (in objectsDir)
def getAllKOI():
	koiDirStuff=os.listdir(objectsDir)
	allKOI = []
	for kk in koiDirStuff:
		if kk.startswith("K"):
			allKOI.append(kk)
	return allKOI

## Get all OBJECTS, not just KOI
def getAllObjects():
	objectDirListing=os.listdir(objectsDir)
	allObjects = []
	for obj in objectDirListing:
		if os.path.isdir(obj):
			allObjects.append(obj)
	return allObjects


# Get all KOI for each filter that have final images
def getAllKOIbyFilter():
	koiDict = {}
	for filt in filterNames:
		koiDict[filt]=[]
		allKOI = getAllKOI()
		for kk in allKOI:
			if os.path.isfile(koiFilterDir(kk,filt)+finalKOIimageFile(kk,filt)):
				koiDict[filt].append(kk)
	return koiDict


# Returns, for each star: (1) apertures, (2) x,y,sky for each star, (3) counts for each ap & star
def readPhotMagFile(fitsdir,fitsfile,magSuffix=".mag.1"):
	magfile = fitsdir+fitsfile+magSuffix
	#print "xx"+magfile+"xx"
	magdata = open(magfile)
	lines = magdata.readlines()
	xySkyDict = {};	starDict={};starn = 0;linen = 0; apertures = []
	atXYline = False; atSkyLine=False; apStartLine=-1
	# Read in lines and locate where each star line (prefaced by the fits file name) is
	for line in lines:
	#	print "line", line.rstrip()	
		elems = line.split()
		linen += 1
		## assumes fitsfile is at least 6 characters long (usually true)
		### Gentle hack: allow for old files, when file name started "finalKOI"
		if ( (elems[0][:6] == fitsfile[:6]) | (elems[0][:6] == "finalK") ): # ie, we have found the line before a new star
			starn += 1	  
	#		print "located another star; total: ",starn
			apertures = []; atXYline = True; apStartLine=-1
		elif atXYline == True:
			xcoord=elems[0]
			ycoord=elems[1]
			xcoordErr=elems[4]
			ycoordErr=elems[5]
	#		print "star #",starn, " has coordinates", xcoord, ycoord
			atXYline = False; atSkyLine=True
		### Step through the apertures
		elif atSkyLine == True:
			skyMean=elems[0]
			skySD=elems[1]
	#		print "star #",starn, " has sky mean and sd", skyMean, skySD
			atSkyLine=False
			xySkyDict[starn]=[xcoord,ycoord,skyMean,skySD,xcoordErr,ycoordErr]
			apStartLine=linen+2
#		print linen, apStartLine, elems[0],(apStartLine != -1),(linen >= apStartLine),(apStartLine != -1) & (linen >= apStartLine)	
		elif (apStartLine != -1) & (linen >= apStartLine):
		#	print elems
			ap = elems[0]
			rawCounts = elems[1]
			area = elems[2]
			skySubCounts = elems[3]
			mag = elems[4]
			magErr = elems[5]
			apertures.append(ap)
			starDict[starn,ap]=[rawCounts,area,skySubCounts,mag,magErr]
	return apertures, starn, xySkyDict, starDict


def importLimitingMagFile(magFile):
	data=open(magFile)
	lines = data.readlines()
	deltaMagDict={}; allDists=[]
	for line in lines:
		line=line.rstrip()
		if line.startswith("File"):
			madeFrom=line.split(" ")[1]
		elif line.startswith("Camera-mode"):
			cameraMode=line
		elif line.startswith("Peak-counts"):
			peakCounts=line.split(" ")[1]
		elif line.startswith("Sigma"):
			sigma=line.split(" ")[1]
		elif line.startswith("2MASS"):
			mag2MASS=line.split(" ")[1]
		elif line.startswith("Annulus-mean"):
			headers=line.split()
			hPos=0
			for hh in headers:
				if hh == "Annulus-mid_arcsec":
					distPos=hPos
				elif hh == "Delta-mag":
					magPos=hPos
				hPos=hPos+1
		else:
			elems=line.split()
			# Do not evaluate! we want the clean strings
			deltaMagDict[elems[distPos]]=eval(elems[magPos])
			allDists.append(elems[distPos])
	deltaMagDict["annuli"]=allDists
	return deltaMagDict

#### Misc
def chunkIt(seq, num):
  avg = len(seq) / float(num)
  out = []
  last = 0.0
	
  while last < len(seq):
    out.append(seq[int(last):int(last + avg)])
    last += avg
	
  return out



###### Get items from header

# In Aug 2012 ascardlist was deprecated, and new header functionality is described in
#            http://stsdas.stsci.edu/download/docs/The_PyFITS_Handbook.pdf
# We're still using it because I don't know what old version of python is on the CF machines
def getStuffFromHeader(fitsfile,keyword,verbose=False):
	hdulist = pyfits.open(fitsfile)
	hdulist.close()
	hdulist.verify('silentfix')
	ff = hdulist[0].header.ascardlist()
	bar = hdulist[0].header.keys()
	value = "NA"
	for nn,item in enumerate(ff):
		#print "\nxx",bar[nn]
		if str(bar[nn]).startswith(keyword):
			value=gb.cleanse(str(item).rstrip().split("=")[1], charList=["\'"," "])
	if verbose:
		print "Reading header of",fitsfile,keyword,value
	return value




def getPlateScaleFromHeader(fitsfile,verbose=False):
	cameraMode =string.replace(getStuffFromHeader(fitsfile,"CAMERA")," ","")
	if (cameraMode=="F/15") | (cameraMode=="f/15") | (cameraMode=="f15") | (cameraMode=="F15"):
		plateScale = 0.0417
	elif (cameraMode=="F/30") | (cameraMode=="f/30") | (cameraMode=="f30") | (cameraMode=="F30"):
		plateScale = 0.02085
	else:
		plateScale = 0
	return plateScale



#### Make a .coo file (assuming you have a .mag file)
def makeCooFileFromMagFile(magDir,fitsFile):
	apertures, nStars, xySkyDict, starDict = readPhotMagFile(magDir,fitsFile)
	coofile = magDir+fitsFile+".coo"
	gb.deleteIfPresent(coofile)
	print coofile, nStars
	print xySkyDict
	g = open(coofile,'w')
	for nn in range(nStars):
		print >>g,xySkyDict[nn+1][0]+" "+xySkyDict[nn+1][1]
	g.close()

##### Get FWHM (assuming you already have a full-featured coo file .coo file)

def getFWHMfromFITScoo(fitsFile,cooFileFull):	
	cr=['\n']
	# Only use the first coordinate
	cooFile=cooFileFull+".short"
	os.system(" head -n 1 "+cooFileFull+" > "+cooFile)
	iraf.tv()
	iraf.imexam.setParam("imagecur",cooFile)
	iraf.imexam.setParam("use_display","no")
	results=iraf.imexam(fitsFile,frame=1,Stdout=1,Stdin=cr)
	# Line 0: headers for coords; 1: coords; 2: header for FWHM etc; we want 3
	# Gaussian is -3rd element, Moffat -2, direct -1
	moffatFWHM = results[3].split()[-2]
	return moffatFWHM	
	
#### DOES NOT ASSUME YOU HAVE .coo FILE
def getFWHM(fitsFile, cooFile, fwhmType="Moffat"):
	if fwhmType == "Moffat":
		col = -2
	elif fwhmType == "Gaussian":
		col = -3
	else: # direct
		col = -1
	iraf.imexam.setParam("imagecur",cooFile)
	iraf.imexam.setParam("use_display","no")
	results = iraf.imexam(fitsFile, frame=1, Stdout=1, Stdin=cr)
	fwhm = results[3].split()[col]
	if fwhm == "INDEF":
		print "Please select another FWHM type:"
		print "0 Gaussian",results[3].split()[-3]
		print "1 Moffat",results[3].split()[-2]
		print "2 Direct",results[3].split()[-1]
		entry = raw_input("New fwhm:")
		if entry == "":
			col = -3
		elif entry == "1":
			col = -2
		else:
			col = -2
		fwhm = results[3].split()[col]
	xx = results[2].split()[0]
	yy = results[2].split()[1]
	return fwhm, xx, yy
	
	
	
### Read in settings file for each KOI

def readSettingsFile(settingsFile,delimiter="\t"):
	data=open(settingsFile)
	lines = data.readlines()
	settingsDict={}
	for line in lines:
		elems=line.rstrip().split(delimiter)
		settingsDict[elems[0]] = elems[1]
	return settingsDict

### Read in comp stars file for each object
def readStarsFile(starsFile,delimiter="\t"):
	data=open(starsFile)
	lines = data.readlines()
	starsInfo=[]
	for line in lines:
		elems=line.rstrip().split(delimiter)
		starsInfo.append(elems)
	return starsInfo



#### File locations
def getDataDir(koi):
	settingsDict=readSettingsFile(settingsFile(koi))
	return settingsDict["Raw_data_dir"]

### Read in list of all frames to use

def useFramesForKOI(settingsFile):
	data=open(settingsFile)
	lines = data.readlines()
	files=[]
	for line in lines:
		files.append(line.rstrip())
	return files



### Convert J-K to Kepler magnitude using Ciardi coordinates
# email from 2011 Feb 18

def jMinusKtoKeplerMag(jMinusK,isDwarf=True):
	if isDwarf:
		a0=0.33254
		a1=4.73570
		a2=-5.96321
		a3=4.93951
	else:
		a0=0.42444
		a1=3.79376
		a2=-2.32673
		a3=1.46026
	return a0 + a1*jMinusK + a1*jMinusK**2 + a1*jMinusK**3



## Find stars on a frame with daophot
#   somewhere might be expecting extra="//.red.sub"

def findStars(frame,fwhm,sigma,thresh,extra="",overwrite=True,interactive=True):
	if overwrite:
		if os.path.isfile(frame+".fullcoo"):
			os.system("rm "+frame+".fullcoo")
	iraf.noao()
	iraf.digiphot()
	iraf.daophot()
	iraf.datapars.setParam("fwhmpsf",fwhm)
	iraf.datapars.setParam("sigma",sigma)
	iraf.findpars.setParam("thresh",thresh)
	foo = iraf.daofind(image=frame+extra,output=frame+".fullcoo",Stdin=cr,Stdout=1)

### This is to read in the file created with findStars
def readFullCooAllStars(frame,myFWHM, myBkg, myThresh, numXpixels=1024, numYpixels=1024, ignoreEdgePixels=20, interactive=True):
	fullCooFile = frame+".fullcoo"
	shortCooFile = frame+".coo"
	if os.path.exists(shortCooFile):
		useFile = shortCooFile
	else:
		useFile = fullCooFile
	data = open(useFile,"r")
	lines = data.readlines()
	data.close()
	coords = []
	useNum = 0
	for line in lines:
		if line[0] != "#":
			elems=line.split()
			# Minimal quality control: don't accept within 20 pix of edge
			if ((eval(elems[0]) > ignoreEdgePixels) & (eval(elems[0]) < (numXpixels-ignoreEdgePixels)) & (eval(elems[1]) > ignoreEdgePixels) & (eval(elems[1]) < (numYpixels-ignoreEdgePixels))):
				coords.append([elems[0],elems[1]])
			else:
				print "rejected as too close to edge:", elems[0], elems[1]
				
	if len(coords)==0:
		print frame+" Did not find any targets; enter new daofind criteria"
		entry = raw_input("FWHM (currently "+str(myFWHM)+"): ")
		if entry != "":
			myFWHM = eval(entry)
		print "Entered: "+entry+" Using:",myFWHM
		entry = raw_input("Bkg Std. dev. (currently "+str(useBkg)+"): ")
		if entry != "":
			myBkg = eval(entry)
		print "Entered: "+entry+" Using:",myBkg
		entry = raw_input("Threshhold (currently "+str(myThresh)+"): ")
		if entry != "":
			myThresh = eval(entry)
		print "Entered: "+entry+" Using:",myThresh
		return myFWHM, myBkg, myThresh
	else:
		print frame
		print " found the following stars ("+str(len(coords))+"): "
		if interactive: ### your first time through, this should definitely be true!
			for nn,coord in enumerate(coords):
				print nn, coord
			print "Your options (enter number):"
			print "[enter] -- accept ALL stars"
			print "r -- redo (prompt for new fwhm, threshhold, bkg sigma)"
			print "2 1 4 -- pick SOME targets (list target FIRST, separate with spaces)"
			print "anything else: accept ALL stars"
			entry = raw_input("Your choice: ")
			print "xxx",entry,"xxx"
			if entry == "r":
				entry1 = raw_input("New fwhm ("+str(myFWHM)+"):  ")
				if entry1 != "":
					myFWHM = eval(entry1)
				entry1 = raw_input("New bkg sigma ("+str(myBkg)+"):  ")
				if entry1 != "":
					myBkg = eval(entry1)
				entry1 = raw_input("New threshhold ("+str(myThresh)+"):  ")
				if entry1 != "":
					myThresh = eval(entry1)
				entry1 = raw_input("Max X ("+str(numXpixels)+"):  ")
				if entry1 != "":
					numXpixels = eval(entry1)
				entry1 = raw_input("Max Y ("+str(numYpixels)+"):  ")
				if entry1 != "":
					numYpixels = eval(entry1)
				entry1 = raw_input("Reject N pixels from edge ("+str(ignoreEdgePixels)+"):  ")
				if entry1 != "":
					ignoreEdgePixels = eval(entry1)
				return myFWHM, myBkg, myThresh, numXpixels, numYpixels, ignoreEdgePixels
			elif entry != "":
				splitEntry = entry.split(" ")
				useStars=[]
				for nn in splitEntry:
					useStars.append(eval(nn))
			else:
				useStars = range(len(coords))
		else: #### Say you really don't care which stars you pick, 'cause it's the hundredth time through
			useStars = range(len(coords))
		print "Using star numbers: ",useStars
	g=open(shortCooFile,"w")
	for uu in useStars:
		print >>g,coords[uu][0],coords[uu][1]
	g.close()
	return True, coords[useStars[0]][0],coords[useStars[0]][1]


#def runBatchPhotometry(useIndCoords=True,fullyAutomatic=False):	
#	if useIndCoords == True:
#		useCoords = "@allcoo"
#	else:
#		useCoords = "first.coo"
#	print useCoords
#	cr=['\n']
#	iraf.cd(reducedDataDir)
#	iraf.noao()
#	iraf.digiphot()
#	iraf.apphot()
#	iraf.phot.setParam('interactive','no')
#	iraf.centerpars.setParam('cbox','5')
##	iraf.photpars.setParam('apertures','2,3,5,10,15,20,30,40,50')
##	iraf.photpars.setParam('apertures','5,10,15,20')
#	iraf.photpars.setParam('apertures','5,8,10,12,15,20,25 ')
#	iraf.fitskypars.setParam('annulus',bestSkyAperture)
#	iraf.fitskypars.setParam('dannulus','10')
#	iraf.phot.setParam('image',"@all")
#	iraf.phot.setParam('coords',useCoords)
#	iraf.phot.setParam('output',"@allout")
#	if fullyAutomatic: ## If you use this option, it will not prompt you for any of the aperture/sky settings
#		iraf.phot(mode='h',Stdin=cr)
#	else: # Otherwise, you can change them at will, and get to press enter a bunch
#		iraf.phot(mode='h')


def createMagFile(inputDir, inputFile, useCoordFile, outputFile, fullyAutomatic=False, aperturesString='5,10,15,20', bestSkyAperture='100'):	
	cr=['\n']
	iraf.cd(inputDir)
	iraf.noao()
	iraf.digiphot()
	iraf.apphot()
	iraf.phot.setParam('interactive','no')
	iraf.centerpars.setParam('cbox','5')
	iraf.photpars.setParam('apertures',aperturesString)
	iraf.fitskypars.setParam('annulus',bestSkyAperture)
	iraf.fitskypars.setParam('dannulus','10')
	iraf.phot.setParam('image',inputFile)
	iraf.phot.setParam('coords',useCoordFile)
	iraf.phot.setParam('output',outputFile)
	if fullyAutomatic: ## If you use this option, it will not prompt you for any of the aperture/sky settings
		iraf.phot(mode='h',Stdin=cr)
	else: # Otherwise, you can change them at will, and get to press enter a bunch
		iraf.phot(mode='h')


